# منطق صفحة المقارنة (بوكينج ↔ نزيل) — مراجعة حرفية

هذا المستند يوثق **آلية الاستيراد** من بوكينج ومن نزيل، و**آلية المطابقة** خطوة بخطوة كما هي في الكود.

---

## الهدف من المشروع (العمولة)

بوكينج يطلب عمولة عن كل حجز **حضر**. المشروع يهدف إلى:
- التأكد أن كل من حضر من بوكينج موجود في نزيل (مطابق)، ومعرفة من دفع في نزيل أقل أو أكثر.
- تحديد **من لم يحضر** (مفقود في نزيل) حتى لا تدفع عمولة عليهم.

راجع `PROJECT_GOAL_COMMISSION.md` لربط كل حالة في النظام بمعناها بالنسبة للعمولة.

---

## 1. قراءة الملفات (Excel/CSV)

### الدالة: `readSheet(file)`

```js
const wb = XLSX.read(e.target.result, { type: 'array' });
resolve(XLSX.utils.sheet_to_json(wb.Sheets[wb.SheetNames[0]], { header: 1 }));
```

- **المدخل:** ملف واحد (من `<input type="file">`).
- **المخرج:** مصفوفة ثنائية الأبعاد `raw`: كل عنصر سطر، وكل سطر مصفوفة خلايا.
- **الملاحظة:** يُستخدم **أول شيت فقط** في الملف (`wb.SheetNames[0]`)، والقيم نصوص/أرقام كما في الإكسل.

---

## 2. اكتشاف صف العناوين واستخراج البيانات

### الدالة: `getData(raw, keys)`

**المعنى:** نبحث عن أول سطر (من أصل 20 سطراً الأولى) يحتوي على **جميع** النصوص في `keys`، ثم نعتبره صف العناوين ونحوّل كل سطر تحته إلى كائن بمفاتيح = عناوين ذلك الصف.

```js
// البحث عن صف العناوين (من 0 إلى 19)
for (let i = 0; i < 20; i++) {
  if (raw[i] && keys.every(k => JSON.stringify(raw[i]).includes(k))) {
    hRow = i;
    break;
  }
}
// إذا لم يُوجد → نرجع []
headers = raw[hRow].map(x => String(x || "").trim());
// كل سطر تحت hRow → كائن: key = headers[j], value = row[j]
return raw.slice(hRow + 1).map(r => {
  let obj = {};
  headers.forEach((h, i) => (obj[h] = r[i]));
  return obj;
});
```

- **الشرط:** `JSON.stringify(raw[i]).includes(k)` يعني أن النص `k` يظهر **في أي مكان** في السطر (قد يكون جزءاً من كلمة أو عمود آخر). العناوين يجب أن تحتوي هذه النصوص.
- **النتيجة:** مصفوفة كائنات، كل كائن = صف، والمفتاح = **نص العمود كما في الملف** (مع trim).

---

## 3. استيراد نزيل (Nazeel)

### استدعاء الاستيراد

```js
cachedN = getData(nRaw, ["إسم العميل"]);
```

- **الملف:** الملف المختار في "نزيل (Guests)" → `nazeelFile` → يُقرأ بـ `readSheet` فيصبح `nRaw`.
- **شرط صف العناوين:** يجب أن يوجد سطر فيه النص **"إسم العميل"** (بهمزة واحدة وإملاء نزيل الشائع).
- **النتيجة:** `cachedN` = مصفوفة كائنات، كل عنصر = ضيف/إقامة في نزيل.

### الأعمدة المستخدمة من نزيل في الكود (بالاسم الحرفي)

| المفتاح في الكود | الاستخدام |
|------------------|-----------|
| `إسم العميل` | اسم الضيف — للمطابقة مع بوكينج (اسم، alias، تجميع، إلخ) |
| `تاريخ الدخول` | تاريخ الدخول — للمطابقة بالتاريخ وتصفية البوكينج |
| `تاريخ الخروج` | تاريخ الخروج — فقط في خطوة "تمديد الإقامة" (extension) |
| `الايجار الكلي` أو `الاجمالي` | السعر الإجمالي في نزيل — للمقارنة مع السعر المتوقع من بوكينج |
| عمود يحتوي "مرجع" أو "مصدر" | يُستخرج اسمه ديناميكياً كـ `refKey` — لربط الحجز بمرجع بوكينج إن وُجد |

- **ملاحظة:** إذا كان اسم العمود في الملف مختلفاً (مثلاً "الإيجار الكلي" أو "الإجمالي") فلن يُستخدم إلا إذا وُجد في الـ headers تحت اسم مطابق تماماً. الكود يبحث عن **`الايجار الكلي`** أو **`الاجمالي`** فقط.

---

## 4. استيراد بوكينج (Booking)

### استدعاء الاستيراد

```js
tempB = getData(bRaw, ["رقم الحجز", "السعر"]);
```

- **الملف:** الملف المختار في "بوكينج (Booking)" → `bookingFile` → يُقرأ فيصبح `bRaw`.
- **شرط صف العناوين:** يجب أن يوجد سطر فيه **"رقم الحجز"** و **"السعر"** معاً.
- **النتيجة:** `tempB` = كل صفوف البوكينج من الملف.

### تصفية بوكينج حسب نطاق تواريخ نزيل

```js
// نطاق تواريخ نزيل: من أصغر "تاريخ الدخول" إلى أكبر "تاريخ الدخول"
cachedN.forEach(r => {
  let d = parseDate(r["تاريخ الدخول"]);
  if (d) {
    if (!minD || d < minD) minD = d;
    if (!maxD || d > maxD) maxD = d;
  }
});
// توسيع النطاق يوم قبل ويوم بعد
if (minD && maxD) {
  minD.setDate(minD.getDate() - 1);
  maxD.setDate(maxD.getDate() + 1);
  cachedB = tempB.filter(b => {
    let d = parseDate(b["تسجيل الوصول"]);
    return !d || (d >= minD && d <= maxD);
  });
} else {
  cachedB = tempB;  // إذا ما في تواريخ نزيل نستخدم كل البوكينج
}
```

- **المستخدم للتاريخ في بوكينج:** العمود **`تسجيل الوصول`** (تاريخ الوصول).
- **النتيجة:** `cachedB` = صفوف البوكينج التي وصولها داخل نطاق نزيل (أو كل البوكينج إذا لم يُستخرج تواريخ من نزيل).

### الأعمدة المستخدمة من بوكينج في الكود (بالاسم الحرفي)

| المفتاح في الكود | الاستخدام |
|------------------|-----------|
| `رقم الحجز` | المرجع — للمطابقة مع عمود "مرجع/مصدر" في نزيل إن وُجد |
| `السعر` | السعر في بوكينج (قبل الضريبة) — يُضرب في `tax` لاحقاً |
| `اسم الضيف\\الضيوف` أو `اسم الضيف` | اسم الضيف — للمطابقة والـ alias والتجميع |
| `تم الحجز من قِبل` | بديل لاسم الضيف في العرض فقط (في `storeResult` → `bName`) |
| `الحالة` | حالة الحجز — "ok" = مؤكد، "cancel" = ملغي، غير ذلك يُحسب NoShow |
| `تسجيل الوصول` | تاريخ الوصول — للتصفية وللمطابقة بالتاريخ |
| `تاريخ المغادرة` | تاريخ المغادرة — فقط في خطوة "تمديد الإقامة" |

---

## 5. معامل الضريبة والبلدية

```js
taxP = parseFloat(taxVal.value) || 0;   // مثال: 15
muniP = parseFloat(muniVal.value) || 0; // مثال: 2.5
tax = 1 + (taxP + muniP) / 100;         // مثال: 1.175
```

- **السعر المتوقع من بوكينج في المقارنة:** دائماً `bPrice * tax` (أي سعر البوكينج + ضريبة + بلدية).

---

## 6. آلية المطابقة (الترتيب الحرفي في الكود)

المطابقة تتم على **كل صف بوكينج** مرة واحدة. أي بوكينج تمت مطابقته يُضاف إلى `processedBooking`، وأي صف نزيل مُستخدم يُضاف إلى `takenNazeel`، ولا يُستخدم مرة ثانية.

### 0. الذاكرة (Alias) — قبل كل شيء

- **المصدر:** IndexedDB، مخزن `aliases`، المفتاح `bName` (اسم بوكينج مُنظَّف بـ `normalize`).
- **الفكرة:** إذا سبق أن المستخدم ربط يدوياً "اسم بوكينج" ↔ "اسم نزيل"، نطبّق هذا الربط أولاً.
- **الشروط:**
  - نأخذ اسم البوكينج: `اسم الضيف\\الضيوف` أو `اسم الضيف`.
  - نستدعي `getAlias(bName)` → نرجع `{ bName, nName }` إذا وُجد.
  - نبحث في **النزيل غير المُستخدم** عن صف فيه `إسم العميل` (بعد normalize) **يحتوي** على `alias.nName`.
  - إذا وُجد → مطابقة من نوع **`alias`**، ونخرج من هذا البوكينج.

### 1. التجميع (Group)

- **الفكرة:** أكثر من حجز بوكينج لنفس الاسم (بعد normalize) يُحسبون كمجموعة، ونبحث عن إقامة نزيل واحدة بإجمالي = مجموع أسعارهم (بعد الضريبة) وتاريخ دخول قريب.
- **الشروط:**
  - تجميع البوكينج حسب `normalize(اسم الضيف\\الضيوف أو اسم الضيف)`.
  - نتعامل فقط مع المجموعات التي فيها **حجزان أو أكثر** (`group.length >= 2`).
  - `totalExp = sum(سعر كل بوكينج في المجموعة * tax)`.
  - `minDate = أصغر تسجيل وصول في المجموعة`.
  - في النزيل غير المُستخدم نبحث عن صف:
    - `|سعر نزيل (الايجار الكلي أو الاجمالي) - totalExp| <= 10`
    - `|تاريخ الدخول نزيل - minDate| <= 2 يوم`
  - إذا وُجد → المطابقة من نوع **`group`**؛ كل عناصر المجموعة تُسجّل، لكن بيانات النزيل تُعرض فقط للعنصر الأول (`isGroupHead`).

### 2. الشلال الفردي (مرجع ثم اسم)

يُطبَّق على كل بوكينج لم يُعالَج بعد (ليس في alias ولا في group).

#### 2.1 مطابقة بالمرجع (ref)

- **الشرط:** في نزيل وُجد عمود اسمه يحتوي "مرجع" أو "مصدر" (`refKey`)، ورقم الحجز في البوكينج غير فارغ.
- **المطابقة:** كل صفوف نزيل التي في عمود `refKey` تظهر فيها قيمة `رقم الحجز` للبوكينج.
- **النتيجة:** نوع **`ref`**، وإيراد نزيل = مجموع أسعار كل تلك الصفوف (`totalNazeelPrice`).

#### 2.2 مطابقة بالاسم + سعر أو تاريخ (name)

- **الشرط:** لم تُحقّق مطابقة ref.
- **منطق المطابقة:**
  - `bParts = getParts(bName)` = كلمات الاسم (بعد normalize) التي طولها > 2.
  - لكل صف نزيل غير مُستخدم:
    - `nName = normalize(إسم العميل)`، `nPrice` من الايجار الكلي أو الاجمالي، `nDate = تاريخ الدخول`.
    - تشابه الأسماء: لكل كلمة في `bParts` إذا وُجدت كلمة في نزيل (بعد getParts) والمسافة ليفنشتاين ≤ 1 نزيد عداد.
    - `nameHit = (simScore >= 2) || (كلمة واحدة فقط في بوكينج و simScore === 1)`.
    - `priceHit = |nPrice - expPrice| < 10`.
    - `dateHit = |nDate - bDate| <= 1.5 يوم`.
  - **الشرط النهائي:** `nameHit && (priceHit || dateHit)`.
- **النتيجة:** نوع **`name`**.

### 3. تمديد الإقامة (extension)

- **الفكرة:** نفس الضيف دخل نفس التاريخ لكن غادر في نزيل **بعد** تاريخ المغادرة في بوكينج (تمديد).
- **الشروط (كلها مطلوبة):**
  - تواريخ وصول ومغادرة موجودة في البوكينج وفي نزيل.
  - `|تاريخ الدخول نزيل - تسجيل الوصول بوكينج| < 1 يوم`.
  - `تاريخ الخروج نزيل > تاريخ المغادرة بوكينج`.
  - `|سعر نزيل - expPrice| < 15`.
- **النتيجة:** نوع **`extension`**.

### 4. التخمين والمفقود (guess / miss)

- **الفكرة:** آخر محاولة: مطابقة بالتاريخ القريب جداً والسعر القريب جداً فقط (بدون اسم). إن لم يُوجد → "مفقود".
- **الشروط للمطابقة (guess):**
  - `|تاريخ الدخول نزيل - تسجيل الوصول بوكينج| < 1 يوم`.
  - `|سعر نزيل - expPrice| <= 3`.
- **النتيجة:** إن وُجد صف نزيل → **`guess`**، وإلا **`miss`**.

---

## 7. تسجيل النتيجة والإحصائيات

### دالة `storeResult(b, n, type, s, tax, isGroupHead, totalNazeelPrice)`

- **type:** أحد: `ref`, `name`, `alias`, `group`, `extension`, `guess`, `miss`, أو يُستبدل لاحقاً بـ `conflict` إذا الحالة ليست "ok".
- **conflict:** إذا `type !== "miss"` وحالة البوكينج لا تحتوي "ok" → يُعدّ تسكين (إلغاء) ويُعرض كـ **`conflict`**.
- **الإيرادات:**
  - دائماً نضيف سعر البوكينج (بعد الضريبة) إلى `s.revB`.
  - نضيف سعر نزيل إلى `s.revN` إلا في حالة group حيث نضيف فقط عند `isGroupHead`.
- **المخرجات:** دفع عنصر واحد إلى `allRowsData` (يُستخدم في الجدول والفلاتر والبحث).

---

## 8. دوال مساعدة مستخدمة في الاستيراد والمطابقة

| الدالة | الوظيفة |
|--------|---------|
| `normalize(s)` | توحيد النص: حروف صغيرة، توحيد همزات و تاء مربوطة و ياء، إزالة "al-", "bin ", "abu ", "mr ", "mrs "، ثم استبدال غير الحروف والمسافات بمسافة و trim. |
| `parseDate(v)` | تحويل رقم إكسل (أو نص بصيغة YYYY-MM-DD أو DD/MM/YYYY) إلى `Date`. |
| `cleanPrice(v)` | استخراج رقم من النص: إزالة كل ما عدا الأرقام والنقطة ثم `parseFloat`. |
| `getParts(name)` | `normalize(name).split(" ").filter(x => x.length > 2)` — كلمات أطول من 2 أحرف. |
| `levenshtein(a, b)` | مسافة ليفنشتاين بين نصين — تُستخدم لمقارنة كلمات الأسماء (≤ 1 = قريبة). |

---

## 9. ملخص سريع لمسار البيانات

1. **نزيل:** ملف → `readSheet` → `getData(nRaw, ["إسم العميل"])` → `cachedN` (أعمدة: إسم العميل، تاريخ الدخول، تاريخ الخروج، الايجار الكلي أو الاجمالي، ومرجع/مصدر إن وُجد).
2. **بوكينج:** ملف → `readSheet` → `getData(bRaw, ["رقم الحجز", "السعر"])` → `tempB` → تصفية حسب `تسجيل الوصول` ضمن نطاق تواريخ نزيل → `cachedB`.
3. **المطابقة:** `process(cachedB, cachedN, tax)` بالترتيب: Alias → Group → Ref → Name → Extension → Guess/Miss.
4. **العرض:** `allRowsData` → `renderTable()` مع الفلاتر والبحث.

إذا غيّرت أسماء الأعمدة في ملفات الإكسل يجب أن تتطابق مع المفاتيح المذكورة أعلاه (أو تعديل الكود ليدعم أسماء أخرى).
