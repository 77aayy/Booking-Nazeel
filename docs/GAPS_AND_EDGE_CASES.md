# ثغرات ومناطق خطر في منطق المطابقة (بوكينج ↔ نزيل)

هذا المستند يوثق **الثغرات والحدود المحتملة** في منطق المطابقة — لاستخدامها عند رفع ملفي بوكينج ونزيل واكتشاف المشاكل.

---

## 0. فلسفة الحالات: نظام ديناميكي — لا يرتبط بأسماء محددة

**الحالات التي يرسلها المستخدم أمثلة على نوع الخلل، وليست قائمة أسماء تُحلّ مرة واحدة فقط.**

- عند رفعك **ملفاً آخر** غير الذي أرسلت منه الحالات، النظام يطبّق **نفس المنطق** (عكس الاسم، اسم فرعي، نفس الكلمات، نقل حرفي عربي↔لاتيني، مرادفات الأنماط، تسامح السعر عند غياب التاريخ). أي ضيف في أي ملف يستفيد إذا تحققت الشروط.
- **مرادفات عربي–إنجليزي** (COMMON_NAME_EQUIVALENTS) = **مكتبة أنماط**: كل مرادف (مثل الطويرقي↔towairqi) يغطي **كل** ضيف في **أي** ملف له نفس النمط. إضافة نمط واحد تُطبَّق على كل الملفات المستقبلية.
- عند ظهور **نمط جديد** في ملف جديد (اسم لم يُطابق رغم أنه نفس الشخص)، يُضاف **النمط** (مرادف أو قاعدة) مرة واحدة فيصبح النظام يغطيه في كل الملفات التالية.
- توثيق الأنماط أدناه يساعد في: (1) معرفة ما تم توقعه مسبقاً، (2) إضافة مرادفات أو قواعد جديدة عند ظهور حالات مشابهة في **أي** ملف.

---

## 1. فلسفة التصميم: توقع أخطاء الموظف

- **الإدخال يتم من خلال موظف** — متوقع أن يغلط في رقم الحجز، الاسم، أو تاريخ الدخول.
- **الاسم قد يختلف بين بوكينج ونزيل** — عربي/إنجليزي، تهجئة مختلفة، ترتيب كلمات.
- **تاريخ الدخول قد يختلف بيوم** — بوكينج 1 يناير ونزيل 2 يناير (تسجيل اليوم التالي).

لذلك تم تطبيق:
- **تسامح تواريخ**: 2 يوم للمطابقة بالاسم والتخمين والتمديد، 3 يوم للتجميع.
- **تسامح أسعار**: 15 للمطابقة بالاسم والتجميع، 8 للتخمين، 20 للتمديد.
- **مرجع رقم الحجز**: مطابقة تتضمن (includes) أو ليفنشتاين ≤ 2 لتفادي خطأ حرف/رقم.
- **عمود الاسم في نزيل**: قبول "إسم العميل" أو "اسم العميل".
- **اسم في التخمين**: wordSimilarity بمسافة 3 (حرف ناقص/زائد).
- **مطابقة بالاسم**: كلمة واحدة متطابقة + تاريخ وسعر قريبان = مطابقة (إشارة قوية).
- **عربي ↔ إنجليزي**: قائمة COMMON_NAME_EQUIVALENTS (محمد↔mohammed، الصاعدي↔alsaedi، العنزي↔alanazi، العسيري↔alasiri، السلمي↔sulami، هادي↔hadi، زاهر↔zaher، البراء/مشبب، إلخ). عند ظهور اسم جديد في ملف آخر يُضاف الزوج هنا.

---

## 2. أنماط متوقعة في ملفات أخرى

| النمط | مثال | ما يُطبَّق |
|--------|------|-----------|
| اسم عربي في نزيل ↔ إنجليزي في بوكينج | محمد ابراهيم الصاعدي ↔ Mohammed Alsaedi؛ عبدالله الغامدي ↔ Abdullah Ghamdi | **قواعد عامة:** (1) نقل حرفي عربي→لاتيني + تسامح مسافة 3 عند المقارنة. (2) إن بدأ النقل بـ "al" يُقارَن اللاتيني أيضاً مع الجزء بعد "al" (مثلاً الغامدي→alghamdy يُقارَن ghamdi مع ghamdy) — فيغطي أي اسم عائلة يبدأ بـ "ال" دون إضافته يدوياً. (3) قائمة COMMON_NAME_EQUIVALENTS لأسماء لا يكفي فيها النقل الحرفي (محمد↔mohammed، إلخ). |
| تهجئة مختلفة لنفس الاسم | Alsaedi / Alsedi | wordSimilarity + namesVeryClose (تسامح سعر/تاريخ) |
| اسم أوسط في نزيل فقط | محمد **ابراهيم** الصاعدي | nameMatchScore يعدّ كلمات؛ تطابق كلمتين (محمد + الصاعدي) كافٍ |
| نفس الحجز بعدة ضيوف في بوكينج | 3 صفوف بنفس رقم الحجز | normalizeBookingByRef + عرض مجمّع |
| ربما مطابق لكن لم يُربط | اسم قريب في نزيل | suggestedMatch + تلميح "ربما مطابق — راجع يدوياً" |
| كلمة واحدة في بوكينج تطابق اسم أوسط في نزيل (ربط خاطئ) | Saws Ka ↔ عبدالله **سعد** عبدالله الغامدي (الصحيح: Sawsen Kalboussi) | **singleWordMatchesFirstOrLast**: عند تطابق كلمة واحدة فقط، نقبل فقط إذا الكلمة في نزيل هي الاسم **الأول أو الأخير** — لا اسم أوسط. + **بادئة في wordSimilarity** (مثل Saws↔Sawsen) لتفضيل الربط الصحيح. |
| كلمتان في البوكينج وتطابق كلمة واحدة فقط مع النزيل (تخمين خاطئ) | Osama Alsuhaymi ↔ **أنسم** عيد سلطان الجبلي البقمي (أنسم ≠ أسامة) | **مرحلة التخمين (guess)**: عند وجود كلمتين أو أكثر في البوكينج نطلب **تطابق كلمتين على الأقل** (nameMatchScore ≥ 2). لا نقبل تخميناً يعتمد على تداخل كلمة واحدة فقط (تفادي ربط أسماء متشابهة لفظياً مثل Osama/أنسم). |
| نفس الكلمات بترتيب مختلف أو **عكس الاسم (أول↔ثاني)** (لم يحضر زائف) | **مشبب البراء** ↔ **البراء مشبب**؛ **Zaher ALASIRI** (بوكينج) ↔ **ALASIRI Zaher** (نزيل) | **مرحلة مبكرة**: ربط صفوف حيث **nameSameWordsOrReversed** (نفس الكلمات أو عكس أول/ثاني) مع تسامح 7 أيام وسعر ≤ 30. **مرحلة عكس الاسم**: إذا الاسم كلمتان ولم يُربط بعد، ربط مع نزيل حيث الاسم معكوس (أول↔ثاني) مع تسامح 7 أيام وسعر 45. **حصر الحالات المرنة**: تقرير التشخيص (`?diagnose=1`) يعرض قائمة "حالات مرنة (عكس الاسم)". |
| اسم فرعي (لم يحضر زائف) | **صالح السلمي** في بوكينج ↔ **صالح دخيل ربه سلطان السلمي** في نزيل | **مرحلة مبكرة ثانية**: ربط صفوف حيث nameSubsetMatch(bParts, nParts) وعدد كلمات البوكينج ≥ 2، مع تسامح 4 أيام و PRICE_TOLERANCE_GUESS×2. |
| ربما مطابق يُقترح شخصاً مُستهلكاً أو غير الأقرب | اقتراح نزيل مربوط لحجز آخر أو ترتيب خاطئ | **ربما مطابق**: يُبنى من **pool** (صفوف نزيل غير مستهلكة) فقط؛ الترتيب: nameSameWordsOrReversed (نفس الكلمات/عكس اسم) أولاً، ثم nameSubsetMatch، ثم أعلى nameMatchScore. |

**النظام ديناميكي:** القواعد العامة (نقل حرفي عربي↔لاتيني + إسقاط "al" + تسامح حتى 4 أحرف) تغطي **أي** اسم في **أي** ملف يتبع النمط. المرادفات تُضاف عندما النقل الحرفي لا يكفي (تهجئة مختلفة مثل محمد↔mohammed). عند ظهور **نمط جديد** في ملف جديد: أضف النمط (مرادف أو قاعدة) مرة واحدة — من ثم يُطبَّق على كل الملفات.

---

## 3. اكتشاف العناوين (getData)

| الثغرة | الوصف |
|--------|--------|
| **مفاتيح حرفية** | نزيل: يجب وجود النص **"إسم العميل"** (بهمزة واحدة). إذا الملف فيه "اسم العميل" أو "اسم العميل" بكتابة أخرى → لا يُكتشف الصف، والنتيجة مصفوفة فارغة. |
| **بوكينج** | يجب وجود **"رقم الحجز"** و **"السعر"** معاً في نفس السطر. أي اختلاف في الاسم (مسافة، همزة، تعريب) → فشل. |
| **أول 20 سطر فقط** | البحث عن صف العناوين من السطر 0 إلى 19. إذا العناوين في السطر 21 → لا يُكتشف. |
| **includes في السطر كله** | `JSON.stringify(raw[i]).includes(k)` — إذا عمود آخر يحتوي النص بالصدفة (مثلاً في وصف) قد يُختار سطر خاطئ كعناوين. |

---

## 4. أسماء الأعمدة المستخدمة لاحقاً

| المصدر | المفتاح في الكود | إذا اختلف في الملف |
|--------|------------------|----------------------|
| نزيل | `إسم العميل` | لا يُقرأ الاسم → مطابقة بالاسم مستحيلة |
| نزيل | `تاريخ الدخول`، `تاريخ الخروج` | تواريخ فارغة أو خاطئة → تصفية ومطابقة تتأثر |
| نزيل | `الايجار الكلي` أو `الاجمالي` | لا يُقرأ السعر → مطابقة السعر تفشل |
| بوكينج | `اسم الضيف\\الضيوف` أو `اسم الضيف` | لا يُقرأ الاسم |
| بوكينج | `تسجيل الوصول`، `تاريخ المغادرة` | تواريخ خاطئة أو فارغة |
| بوكينج | `الحالة` | لا يُعرف مؤكد/ملغي بشكل صحيح |

---

## 5. تصفية البوكينج حسب تواريخ نزيل

| الثغرة | الوصف |
|--------|--------|
| **تعديل minD/maxD في المكان** | `minD.setDate(minD.getDate()-1)` يغيّر الكائن نفسه. إذا استُخدمت التواريخ لاحقاً في مكان آخر قد يظهر سلوك غير متوقع. |
| **بوكينج بدون تاريخ وصول** | `return !d \|\| (d>=minD && d<=maxD)` — إذا `تسجيل الوصول` فارغ يُحسب البوكينج "داخل النطاق" ويُبقى. قد يبقى بوكينج قديم لا علاقة له بنطاق نزيل. |
| **نزيل بدون تواريخ** | إذا كل صفوف نزيل بدون `تاريخ الدخول` → minD/maxD يبقيان null → لا تصفية، يُستخدم كل البوكينج. |

---

## 6. ترتيب المطابقة واستهلاك النزيل

| الثغرة | الوصف |
|--------|--------|
| **أول مطابقة تأخذ النزيل** | أي صف نزيل يُربط مرة واحدة فقط (`takenNazeel`). إذا مطابقة خاطئة (مثلاً بالاسم الضعيف) أخذت النزيل الصحيح → الحجز الصحيح يبقى "مفقود". |
| **Alias أولاً** | الربط اليدوي (الذاكرة) يُطبّق أولاً. إذا alias خاطئ أو قديم → يربط بوكينج بنزيل غير صحيح ويستهلك ذلك النزيل. |
| **لا إعادة توزيع** | لا يوجد مرحلة "مراجعة": بعد انتهاء process لا يُعاد فحص المفقود أو التعارض. |

---

## 7. مطابقة بالمرجع (ref)

| الثغرة | الوصف |
|--------|--------|
| **includes وليس تساوي** | `String(x.n[refKey]||"").includes(bRef)` — إذا رقم الحجز "12345" والمرجع في نزيل "12345678" أو "12345 - إضافي" → تطابق. العكس: إذا المرجع "12345" ورقم الحجز "1234" لا يطابق (صحيح). لكن إذا المرجع "1234" ورقم الحجز "12345" → يطابق (ربط خاطئ محتمل). |
| **refKey من nazeel[0]** | إذا `nazeel` فارغ → `nazeel[0]` undefined → قد يسبب خطأ عند `Object.keys(nazeel[0]\|\|{})`. |

---

## 8. مطابقة بالاسم (name)

| الثغرة | الوصف |
|--------|--------|
| **كلمات قصيرة تُهمل** | `getParts` = كلمات أطول من 2 أحرف فقط. اسم من كلمة واحدة قصيرة أو كلمتين قصيرتين قد لا يعطي أجزاء كافية. |
| **ليفنشتاين ≤ 1** | تسامح صغير. اختلاف حرفين (مثلاً محمد vs محمود) قد لا يطابق. |
| **شرط الاسم** | `(simScore >= 2) \|\| (بوكينج كلمة واحدة و simScore === 1)` — إذا الاسم مركّب وكلمة واحدة فقط تطابقت → قد لا يكفي. |
| **أول تطابق من الـ pool** | `pool.find(...)` يعيد أول نزيل يطابق. إذا أكثر من ضيف نزيل بنفس الاسم/سعر/تاريخ قد يُربط البوكينج بأي واحد منهم (ليس بالضرورة الصحيح). |

---

## 9. التجميع (group)

| الثغرة | الوصف |
|--------|--------|
| **مجموع السعر ± 10** | `Math.abs(nPrice - totalExp) <= 10` — ثابت. مع ضريبة وبلدية وتقريب قد يكون الفرق أكبر من 10 في حالات حقيقية. |
| **التاريخ ± 2 يوم** | قد يكون التجميع لرحلات متقاربة لكن ليست نفس الرحلة. |
| **أول نزيل يطابق** | لا تحقق من أن اسم النزيل قريب من اسم المجموعة. |

---

## 10. التخمين (guess) والمفقود (miss)

| الثغرة | الوصف |
|--------|--------|
| **فرق السعر ≤ 3** | تخمين صارم جداً. أي فرق أكبر (تقريب، عمولة، ضريبة مختلفة) → يُعتبر "مفقود". |
| **التاريخ ± 1 يوم** | نفس اليوم فقط تقريباً. فرق يوم واحد → لا تخمين. |
| **لا مرحلة ثانية** | من انتهى "مفقود" لا يُعاد فحصه بتسامح أوسع. |
| **تخمين بكلمة واحدة فقط (بوكينج 2+ كلمات)** | لتجنب ربط خاطئ (مثل Osama Alsuhaymi ↔ أنسم عيد...): في مرحلة التخمين نطلب **nameMatchScore ≥ 2** عندما البوكينج فيه كلمتان أو أكثر؛ لا يكفي تداخل كلمة واحدة (guessNameOverlap فقط). |
| **فرصة أخيرة** | بعد التخمين وقبل "مفقود": ربط أي بوكينج مع نزيل حيث **nameMatchScore ≥ 2** وتاريخ ضمن 7 أيام وسعر ضمن 45 — لاصطياد ما فاته التسامح في المراحل السابقة. |
| **تقرير تشخيص** | إضافة `?diagnose=1` (مع `?loadSample=1`) يعرض تقريراً من **البيانات الفعلية**: كل "لم يحضر" مع كل مرشحي نزيل (نفس الكلمات / فرعي / تطابق كلمات) وفرق السعر وفرق الأيام — لرصد الثغرات. |

---

## 11. التمديد (extension)

| الثغرة | الوصف |
|--------|--------|
| **السعر ± 15** | قد لا يكفي إذا تمديد الإقامة بسعر ليلة إضافية كبير. |
| **أول تطابق** | نفس مشكلة "أول نزيل يطابق". |

---

## 12. التواريخ والأرقام

| الثغرة | الوصف |
|--------|--------|
| **parseDate** | يدعم رقم إكسل، و YYYY-MM-DD، و DD/MM/YYYY. تنسيقات أخرى (مثلاً نص عربي أو شهر بالاسم) قد تُرجع null. |
| **cleanPrice** | `replace(/[^0-9.]/g, "")` — الفاصلة العشرية في بعض اللغات `,` تُحذف فيصبح الرقم خاطئاً (مثلاً 1.234,56 → 123456). |
| **تعديل التاريخ** | استخدام `setDate` يعدّل الكائن الأصلي؛ إذا نطاق التواريخ يُستخدم في أكثر من مكان قد يظهر سلوك غير متوقع. |

---

## 13. حالات حدودية

| الثغرة | الوصف | الحالة |
|--------|--------|--------|
| **نزيل أو بوكينج فارغ** | إذا getData يرجع [] لأحد الملفين → process يعمل على مصفوفات فارغة؛ الإحصائيات ستكون صفر وقد يظهر خطأ عند الوصول لـ nazeel[0]. | ⚠️ يُنصح بفحص طول المصفوفات قبل process. |
| **صفوف بوكينج مكررة (نفس رقم الحجز)** | نفس الحجز بعدة ضيوف في الملف → **يُعالج كحجز واحد**: تطبيع عند الإدخال (`normalizeBookingByRef`) يجمّع الصفوف حسب رقم الحجز ويدمج الأسماء؛ الإحصائيات والجدول يعكسان حجزاً واحداً. | ✅ مُعالَج. |
| **تطابق واحد لنزيل مع أكثر من بوكينج** | المنطق يمنع ذلك (takenNazeel) — لكن قد يربط أول بوكينج فقط ويُعتبر الباقي مفقود. | ⚠️ معروف. |

---

## ما الذي أفعله عند رفع الملفين؟

1. **فحص العناوين**: التأكد من وجود المفاتيح المتوقعة (إسم العميل، رقم الحجز، السعر، تسجيل الوصول، تاريخ الدخول، الايجار الكلي أو الاجمالي) وأسماء الأعمدة الفعلية.
2. **عينات من البيانات**: فحص صفوف نموذجية لأشكال التواريخ والأسعار والأسماء.
3. **تطبيق القائمة أعلاه**: ربط أي سلوك غريب (مفقود كثير، مطابقة خاطئة، تعارض) بالثغرات المناسبة.
4. **اقتراح تعديلات**: تغييرات في الكود أو في تنسيق الملفات لسد الثغرات التي تظهر على ملفاتك.
5. **عند ظهور نمط جديد في ملف آخر**: إضافة الزوج إلى COMMON_NAME_EQUIVALENTS (إن كان عربي↔إنجليزي) أو توسيع التسامح حسب النمط، ثم توثيق النمط في قسم "أنماط متوقعة في ملفات أخرى" حتى يستفيد منه أي ملف مستقبلي.

ارفع ملف بوكينج وملف نزيل (أو عيّنة منهما إذا كانت كبيرة) وسأحلل بناءً على هذا المستند وأُظهر النتائج والاقتراحات.
